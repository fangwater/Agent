// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IntrnlMsg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_IntrnlMsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_IntrnlMsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_IntrnlMsg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_IntrnlMsg_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_IntrnlMsg_2eproto;
namespace message {
namespace intrnl {
class CommHeader;
struct CommHeaderDefaultTypeInternal;
extern CommHeaderDefaultTypeInternal _CommHeader_default_instance_;
class IntrnlMsg;
struct IntrnlMsgDefaultTypeInternal;
extern IntrnlMsgDefaultTypeInternal _IntrnlMsg_default_instance_;
class IntrnlMsgData;
struct IntrnlMsgDataDefaultTypeInternal;
extern IntrnlMsgDataDefaultTypeInternal _IntrnlMsgData_default_instance_;
class IntrnlMsgExtData;
struct IntrnlMsgExtDataDefaultTypeInternal;
extern IntrnlMsgExtDataDefaultTypeInternal _IntrnlMsgExtData_default_instance_;
}  // namespace intrnl
}  // namespace message
PROTOBUF_NAMESPACE_OPEN
template<> ::message::intrnl::CommHeader* Arena::CreateMaybeMessage<::message::intrnl::CommHeader>(Arena*);
template<> ::message::intrnl::IntrnlMsg* Arena::CreateMaybeMessage<::message::intrnl::IntrnlMsg>(Arena*);
template<> ::message::intrnl::IntrnlMsgData* Arena::CreateMaybeMessage<::message::intrnl::IntrnlMsgData>(Arena*);
template<> ::message::intrnl::IntrnlMsgExtData* Arena::CreateMaybeMessage<::message::intrnl::IntrnlMsgExtData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace message {
namespace intrnl {

// ===================================================================

class CommHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.intrnl.CommHeader) */ {
 public:
  inline CommHeader() : CommHeader(nullptr) {}
  ~CommHeader() override;
  explicit PROTOBUF_CONSTEXPR CommHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommHeader(const CommHeader& from);
  CommHeader(CommHeader&& from) noexcept
    : CommHeader() {
    *this = ::std::move(from);
  }

  inline CommHeader& operator=(const CommHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommHeader& operator=(CommHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommHeader* internal_default_instance() {
    return reinterpret_cast<const CommHeader*>(
               &_CommHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CommHeader& a, CommHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(CommHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommHeader& from) {
    CommHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.intrnl.CommHeader";
  }
  protected:
  explicit CommHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSndrCmptIdFieldNumber = 2,
    kSndrSubIdFieldNumber = 3,
    kTgtCmpntIdFieldNumber = 4,
    kTgtSubIdFieldNumber = 5,
    kMsgSndngTmFieldNumber = 7,
    kMsgUuidFieldNumber = 8,
    kSesnIdFieldNumber = 10,
    kTpcNmFieldNumber = 11,
    kSrcvIdFieldNumber = 1,
    kMsgSrcEndFieldNumber = 6,
    kDplcFFieldNumber = 9,
    kTstMdFFieldNumber = 12,
  };
  // optional string sndrCmptId = 2;
  bool has_sndrcmptid() const;
  private:
  bool _internal_has_sndrcmptid() const;
  public:
  void clear_sndrcmptid();
  const std::string& sndrcmptid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sndrcmptid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sndrcmptid();
  PROTOBUF_NODISCARD std::string* release_sndrcmptid();
  void set_allocated_sndrcmptid(std::string* sndrcmptid);
  private:
  const std::string& _internal_sndrcmptid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sndrcmptid(const std::string& value);
  std::string* _internal_mutable_sndrcmptid();
  public:

  // optional string sndrSubId = 3;
  bool has_sndrsubid() const;
  private:
  bool _internal_has_sndrsubid() const;
  public:
  void clear_sndrsubid();
  const std::string& sndrsubid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sndrsubid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sndrsubid();
  PROTOBUF_NODISCARD std::string* release_sndrsubid();
  void set_allocated_sndrsubid(std::string* sndrsubid);
  private:
  const std::string& _internal_sndrsubid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sndrsubid(const std::string& value);
  std::string* _internal_mutable_sndrsubid();
  public:

  // optional string tgtCmpntId = 4;
  bool has_tgtcmpntid() const;
  private:
  bool _internal_has_tgtcmpntid() const;
  public:
  void clear_tgtcmpntid();
  const std::string& tgtcmpntid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tgtcmpntid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tgtcmpntid();
  PROTOBUF_NODISCARD std::string* release_tgtcmpntid();
  void set_allocated_tgtcmpntid(std::string* tgtcmpntid);
  private:
  const std::string& _internal_tgtcmpntid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tgtcmpntid(const std::string& value);
  std::string* _internal_mutable_tgtcmpntid();
  public:

  // optional string tgtSubId = 5;
  bool has_tgtsubid() const;
  private:
  bool _internal_has_tgtsubid() const;
  public:
  void clear_tgtsubid();
  const std::string& tgtsubid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tgtsubid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tgtsubid();
  PROTOBUF_NODISCARD std::string* release_tgtsubid();
  void set_allocated_tgtsubid(std::string* tgtsubid);
  private:
  const std::string& _internal_tgtsubid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tgtsubid(const std::string& value);
  std::string* _internal_mutable_tgtsubid();
  public:

  // optional string msgSndngTm = 7;
  bool has_msgsndngtm() const;
  private:
  bool _internal_has_msgsndngtm() const;
  public:
  void clear_msgsndngtm();
  const std::string& msgsndngtm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msgsndngtm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msgsndngtm();
  PROTOBUF_NODISCARD std::string* release_msgsndngtm();
  void set_allocated_msgsndngtm(std::string* msgsndngtm);
  private:
  const std::string& _internal_msgsndngtm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msgsndngtm(const std::string& value);
  std::string* _internal_mutable_msgsndngtm();
  public:

  // optional string msgUuid = 8;
  bool has_msguuid() const;
  private:
  bool _internal_has_msguuid() const;
  public:
  void clear_msguuid();
  const std::string& msguuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msguuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msguuid();
  PROTOBUF_NODISCARD std::string* release_msguuid();
  void set_allocated_msguuid(std::string* msguuid);
  private:
  const std::string& _internal_msguuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msguuid(const std::string& value);
  std::string* _internal_mutable_msguuid();
  public:

  // optional string sesnId = 10;
  bool has_sesnid() const;
  private:
  bool _internal_has_sesnid() const;
  public:
  void clear_sesnid();
  const std::string& sesnid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sesnid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sesnid();
  PROTOBUF_NODISCARD std::string* release_sesnid();
  void set_allocated_sesnid(std::string* sesnid);
  private:
  const std::string& _internal_sesnid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sesnid(const std::string& value);
  std::string* _internal_mutable_sesnid();
  public:

  // optional string tpcNm = 11;
  bool has_tpcnm() const;
  private:
  bool _internal_has_tpcnm() const;
  public:
  void clear_tpcnm();
  const std::string& tpcnm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tpcnm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tpcnm();
  PROTOBUF_NODISCARD std::string* release_tpcnm();
  void set_allocated_tpcnm(std::string* tpcnm);
  private:
  const std::string& _internal_tpcnm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tpcnm(const std::string& value);
  std::string* _internal_mutable_tpcnm();
  public:

  // optional int32 srcvId = 1;
  bool has_srcvid() const;
  private:
  bool _internal_has_srcvid() const;
  public:
  void clear_srcvid();
  int32_t srcvid() const;
  void set_srcvid(int32_t value);
  private:
  int32_t _internal_srcvid() const;
  void _internal_set_srcvid(int32_t value);
  public:

  // optional int32 msgSrcEnd = 6;
  bool has_msgsrcend() const;
  private:
  bool _internal_has_msgsrcend() const;
  public:
  void clear_msgsrcend();
  int32_t msgsrcend() const;
  void set_msgsrcend(int32_t value);
  private:
  int32_t _internal_msgsrcend() const;
  void _internal_set_msgsrcend(int32_t value);
  public:

  // optional int32 dplcF = 9;
  bool has_dplcf() const;
  private:
  bool _internal_has_dplcf() const;
  public:
  void clear_dplcf();
  int32_t dplcf() const;
  void set_dplcf(int32_t value);
  private:
  int32_t _internal_dplcf() const;
  void _internal_set_dplcf(int32_t value);
  public:

  // optional int32 tstMdF = 12;
  bool has_tstmdf() const;
  private:
  bool _internal_has_tstmdf() const;
  public:
  void clear_tstmdf();
  int32_t tstmdf() const;
  void set_tstmdf(int32_t value);
  private:
  int32_t _internal_tstmdf() const;
  void _internal_set_tstmdf(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.intrnl.CommHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sndrcmptid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sndrsubid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tgtcmpntid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tgtsubid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msgsndngtm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msguuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sesnid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tpcnm_;
    int32_t srcvid_;
    int32_t msgsrcend_;
    int32_t dplcf_;
    int32_t tstmdf_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IntrnlMsg_2eproto;
};
// -------------------------------------------------------------------

class IntrnlMsgData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.intrnl.IntrnlMsgData) */ {
 public:
  inline IntrnlMsgData() : IntrnlMsgData(nullptr) {}
  ~IntrnlMsgData() override;
  explicit PROTOBUF_CONSTEXPR IntrnlMsgData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntrnlMsgData(const IntrnlMsgData& from);
  IntrnlMsgData(IntrnlMsgData&& from) noexcept
    : IntrnlMsgData() {
    *this = ::std::move(from);
  }

  inline IntrnlMsgData& operator=(const IntrnlMsgData& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntrnlMsgData& operator=(IntrnlMsgData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntrnlMsgData& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntrnlMsgData* internal_default_instance() {
    return reinterpret_cast<const IntrnlMsgData*>(
               &_IntrnlMsgData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IntrnlMsgData& a, IntrnlMsgData& b) {
    a.Swap(&b);
  }
  inline void Swap(IntrnlMsgData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntrnlMsgData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntrnlMsgData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntrnlMsgData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntrnlMsgData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntrnlMsgData& from) {
    IntrnlMsgData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntrnlMsgData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.intrnl.IntrnlMsgData";
  }
  protected:
  explicit IntrnlMsgData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kMsgTypeFieldNumber = 1,
    kMsgLenFieldNumber = 2,
  };
  // optional bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional int32 msgType = 1;
  bool has_msgtype() const;
  private:
  bool _internal_has_msgtype() const;
  public:
  void clear_msgtype();
  int32_t msgtype() const;
  void set_msgtype(int32_t value);
  private:
  int32_t _internal_msgtype() const;
  void _internal_set_msgtype(int32_t value);
  public:

  // optional int32 msgLen = 2;
  bool has_msglen() const;
  private:
  bool _internal_has_msglen() const;
  public:
  void clear_msglen();
  int32_t msglen() const;
  void set_msglen(int32_t value);
  private:
  int32_t _internal_msglen() const;
  void _internal_set_msglen(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.intrnl.IntrnlMsgData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int32_t msgtype_;
    int32_t msglen_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IntrnlMsg_2eproto;
};
// -------------------------------------------------------------------

class IntrnlMsgExtData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.intrnl.IntrnlMsgExtData) */ {
 public:
  inline IntrnlMsgExtData() : IntrnlMsgExtData(nullptr) {}
  ~IntrnlMsgExtData() override;
  explicit PROTOBUF_CONSTEXPR IntrnlMsgExtData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntrnlMsgExtData(const IntrnlMsgExtData& from);
  IntrnlMsgExtData(IntrnlMsgExtData&& from) noexcept
    : IntrnlMsgExtData() {
    *this = ::std::move(from);
  }

  inline IntrnlMsgExtData& operator=(const IntrnlMsgExtData& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntrnlMsgExtData& operator=(IntrnlMsgExtData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntrnlMsgExtData& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntrnlMsgExtData* internal_default_instance() {
    return reinterpret_cast<const IntrnlMsgExtData*>(
               &_IntrnlMsgExtData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IntrnlMsgExtData& a, IntrnlMsgExtData& b) {
    a.Swap(&b);
  }
  inline void Swap(IntrnlMsgExtData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntrnlMsgExtData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntrnlMsgExtData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntrnlMsgExtData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntrnlMsgExtData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntrnlMsgExtData& from) {
    IntrnlMsgExtData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntrnlMsgExtData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.intrnl.IntrnlMsgExtData";
  }
  protected:
  explicit IntrnlMsgExtData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataCntFieldNumber = 1,
  };
  // optional int32 dataCnt = 1;
  bool has_datacnt() const;
  private:
  bool _internal_has_datacnt() const;
  public:
  void clear_datacnt();
  int32_t datacnt() const;
  void set_datacnt(int32_t value);
  private:
  int32_t _internal_datacnt() const;
  void _internal_set_datacnt(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.intrnl.IntrnlMsgExtData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t datacnt_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IntrnlMsg_2eproto;
};
// -------------------------------------------------------------------

class IntrnlMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.intrnl.IntrnlMsg) */ {
 public:
  inline IntrnlMsg() : IntrnlMsg(nullptr) {}
  ~IntrnlMsg() override;
  explicit PROTOBUF_CONSTEXPR IntrnlMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntrnlMsg(const IntrnlMsg& from);
  IntrnlMsg(IntrnlMsg&& from) noexcept
    : IntrnlMsg() {
    *this = ::std::move(from);
  }

  inline IntrnlMsg& operator=(const IntrnlMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntrnlMsg& operator=(IntrnlMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntrnlMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntrnlMsg* internal_default_instance() {
    return reinterpret_cast<const IntrnlMsg*>(
               &_IntrnlMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IntrnlMsg& a, IntrnlMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(IntrnlMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntrnlMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntrnlMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntrnlMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntrnlMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntrnlMsg& from) {
    IntrnlMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntrnlMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.intrnl.IntrnlMsg";
  }
  protected:
  explicit IntrnlMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntrnMsgDataFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kIntrnlMsgExtDataFieldNumber = 3,
  };
  // repeated .message.intrnl.IntrnlMsgData intrnMsgData = 2;
  int intrnmsgdata_size() const;
  private:
  int _internal_intrnmsgdata_size() const;
  public:
  void clear_intrnmsgdata();
  ::message::intrnl::IntrnlMsgData* mutable_intrnmsgdata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::intrnl::IntrnlMsgData >*
      mutable_intrnmsgdata();
  private:
  const ::message::intrnl::IntrnlMsgData& _internal_intrnmsgdata(int index) const;
  ::message::intrnl::IntrnlMsgData* _internal_add_intrnmsgdata();
  public:
  const ::message::intrnl::IntrnlMsgData& intrnmsgdata(int index) const;
  ::message::intrnl::IntrnlMsgData* add_intrnmsgdata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::intrnl::IntrnlMsgData >&
      intrnmsgdata() const;

  // optional .message.intrnl.CommHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::message::intrnl::CommHeader& header() const;
  PROTOBUF_NODISCARD ::message::intrnl::CommHeader* release_header();
  ::message::intrnl::CommHeader* mutable_header();
  void set_allocated_header(::message::intrnl::CommHeader* header);
  private:
  const ::message::intrnl::CommHeader& _internal_header() const;
  ::message::intrnl::CommHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::message::intrnl::CommHeader* header);
  ::message::intrnl::CommHeader* unsafe_arena_release_header();

  // optional .message.intrnl.IntrnlMsgExtData IntrnlMsgExtData = 3;
  bool has_intrnlmsgextdata() const;
  private:
  bool _internal_has_intrnlmsgextdata() const;
  public:
  void clear_intrnlmsgextdata();
  const ::message::intrnl::IntrnlMsgExtData& intrnlmsgextdata() const;
  PROTOBUF_NODISCARD ::message::intrnl::IntrnlMsgExtData* release_intrnlmsgextdata();
  ::message::intrnl::IntrnlMsgExtData* mutable_intrnlmsgextdata();
  void set_allocated_intrnlmsgextdata(::message::intrnl::IntrnlMsgExtData* intrnlmsgextdata);
  private:
  const ::message::intrnl::IntrnlMsgExtData& _internal_intrnlmsgextdata() const;
  ::message::intrnl::IntrnlMsgExtData* _internal_mutable_intrnlmsgextdata();
  public:
  void unsafe_arena_set_allocated_intrnlmsgextdata(
      ::message::intrnl::IntrnlMsgExtData* intrnlmsgextdata);
  ::message::intrnl::IntrnlMsgExtData* unsafe_arena_release_intrnlmsgextdata();

  // @@protoc_insertion_point(class_scope:message.intrnl.IntrnlMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::intrnl::IntrnlMsgData > intrnmsgdata_;
    ::message::intrnl::CommHeader* header_;
    ::message::intrnl::IntrnlMsgExtData* intrnlmsgextdata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IntrnlMsg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CommHeader

// optional int32 srcvId = 1;
inline bool CommHeader::_internal_has_srcvid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CommHeader::has_srcvid() const {
  return _internal_has_srcvid();
}
inline void CommHeader::clear_srcvid() {
  _impl_.srcvid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t CommHeader::_internal_srcvid() const {
  return _impl_.srcvid_;
}
inline int32_t CommHeader::srcvid() const {
  // @@protoc_insertion_point(field_get:message.intrnl.CommHeader.srcvId)
  return _internal_srcvid();
}
inline void CommHeader::_internal_set_srcvid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.srcvid_ = value;
}
inline void CommHeader::set_srcvid(int32_t value) {
  _internal_set_srcvid(value);
  // @@protoc_insertion_point(field_set:message.intrnl.CommHeader.srcvId)
}

// optional string sndrCmptId = 2;
inline bool CommHeader::_internal_has_sndrcmptid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommHeader::has_sndrcmptid() const {
  return _internal_has_sndrcmptid();
}
inline void CommHeader::clear_sndrcmptid() {
  _impl_.sndrcmptid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommHeader::sndrcmptid() const {
  // @@protoc_insertion_point(field_get:message.intrnl.CommHeader.sndrCmptId)
  return _internal_sndrcmptid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommHeader::set_sndrcmptid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sndrcmptid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.intrnl.CommHeader.sndrCmptId)
}
inline std::string* CommHeader::mutable_sndrcmptid() {
  std::string* _s = _internal_mutable_sndrcmptid();
  // @@protoc_insertion_point(field_mutable:message.intrnl.CommHeader.sndrCmptId)
  return _s;
}
inline const std::string& CommHeader::_internal_sndrcmptid() const {
  return _impl_.sndrcmptid_.Get();
}
inline void CommHeader::_internal_set_sndrcmptid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sndrcmptid_.Set(value, GetArenaForAllocation());
}
inline std::string* CommHeader::_internal_mutable_sndrcmptid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sndrcmptid_.Mutable(GetArenaForAllocation());
}
inline std::string* CommHeader::release_sndrcmptid() {
  // @@protoc_insertion_point(field_release:message.intrnl.CommHeader.sndrCmptId)
  if (!_internal_has_sndrcmptid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sndrcmptid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sndrcmptid_.IsDefault()) {
    _impl_.sndrcmptid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommHeader::set_allocated_sndrcmptid(std::string* sndrcmptid) {
  if (sndrcmptid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sndrcmptid_.SetAllocated(sndrcmptid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sndrcmptid_.IsDefault()) {
    _impl_.sndrcmptid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.intrnl.CommHeader.sndrCmptId)
}

// optional string sndrSubId = 3;
inline bool CommHeader::_internal_has_sndrsubid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommHeader::has_sndrsubid() const {
  return _internal_has_sndrsubid();
}
inline void CommHeader::clear_sndrsubid() {
  _impl_.sndrsubid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommHeader::sndrsubid() const {
  // @@protoc_insertion_point(field_get:message.intrnl.CommHeader.sndrSubId)
  return _internal_sndrsubid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommHeader::set_sndrsubid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.sndrsubid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.intrnl.CommHeader.sndrSubId)
}
inline std::string* CommHeader::mutable_sndrsubid() {
  std::string* _s = _internal_mutable_sndrsubid();
  // @@protoc_insertion_point(field_mutable:message.intrnl.CommHeader.sndrSubId)
  return _s;
}
inline const std::string& CommHeader::_internal_sndrsubid() const {
  return _impl_.sndrsubid_.Get();
}
inline void CommHeader::_internal_set_sndrsubid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sndrsubid_.Set(value, GetArenaForAllocation());
}
inline std::string* CommHeader::_internal_mutable_sndrsubid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sndrsubid_.Mutable(GetArenaForAllocation());
}
inline std::string* CommHeader::release_sndrsubid() {
  // @@protoc_insertion_point(field_release:message.intrnl.CommHeader.sndrSubId)
  if (!_internal_has_sndrsubid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.sndrsubid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sndrsubid_.IsDefault()) {
    _impl_.sndrsubid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommHeader::set_allocated_sndrsubid(std::string* sndrsubid) {
  if (sndrsubid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sndrsubid_.SetAllocated(sndrsubid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sndrsubid_.IsDefault()) {
    _impl_.sndrsubid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.intrnl.CommHeader.sndrSubId)
}

// optional string tgtCmpntId = 4;
inline bool CommHeader::_internal_has_tgtcmpntid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommHeader::has_tgtcmpntid() const {
  return _internal_has_tgtcmpntid();
}
inline void CommHeader::clear_tgtcmpntid() {
  _impl_.tgtcmpntid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommHeader::tgtcmpntid() const {
  // @@protoc_insertion_point(field_get:message.intrnl.CommHeader.tgtCmpntId)
  return _internal_tgtcmpntid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommHeader::set_tgtcmpntid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.tgtcmpntid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.intrnl.CommHeader.tgtCmpntId)
}
inline std::string* CommHeader::mutable_tgtcmpntid() {
  std::string* _s = _internal_mutable_tgtcmpntid();
  // @@protoc_insertion_point(field_mutable:message.intrnl.CommHeader.tgtCmpntId)
  return _s;
}
inline const std::string& CommHeader::_internal_tgtcmpntid() const {
  return _impl_.tgtcmpntid_.Get();
}
inline void CommHeader::_internal_set_tgtcmpntid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tgtcmpntid_.Set(value, GetArenaForAllocation());
}
inline std::string* CommHeader::_internal_mutable_tgtcmpntid() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.tgtcmpntid_.Mutable(GetArenaForAllocation());
}
inline std::string* CommHeader::release_tgtcmpntid() {
  // @@protoc_insertion_point(field_release:message.intrnl.CommHeader.tgtCmpntId)
  if (!_internal_has_tgtcmpntid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.tgtcmpntid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tgtcmpntid_.IsDefault()) {
    _impl_.tgtcmpntid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommHeader::set_allocated_tgtcmpntid(std::string* tgtcmpntid) {
  if (tgtcmpntid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.tgtcmpntid_.SetAllocated(tgtcmpntid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tgtcmpntid_.IsDefault()) {
    _impl_.tgtcmpntid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.intrnl.CommHeader.tgtCmpntId)
}

// optional string tgtSubId = 5;
inline bool CommHeader::_internal_has_tgtsubid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommHeader::has_tgtsubid() const {
  return _internal_has_tgtsubid();
}
inline void CommHeader::clear_tgtsubid() {
  _impl_.tgtsubid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommHeader::tgtsubid() const {
  // @@protoc_insertion_point(field_get:message.intrnl.CommHeader.tgtSubId)
  return _internal_tgtsubid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommHeader::set_tgtsubid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.tgtsubid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.intrnl.CommHeader.tgtSubId)
}
inline std::string* CommHeader::mutable_tgtsubid() {
  std::string* _s = _internal_mutable_tgtsubid();
  // @@protoc_insertion_point(field_mutable:message.intrnl.CommHeader.tgtSubId)
  return _s;
}
inline const std::string& CommHeader::_internal_tgtsubid() const {
  return _impl_.tgtsubid_.Get();
}
inline void CommHeader::_internal_set_tgtsubid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tgtsubid_.Set(value, GetArenaForAllocation());
}
inline std::string* CommHeader::_internal_mutable_tgtsubid() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.tgtsubid_.Mutable(GetArenaForAllocation());
}
inline std::string* CommHeader::release_tgtsubid() {
  // @@protoc_insertion_point(field_release:message.intrnl.CommHeader.tgtSubId)
  if (!_internal_has_tgtsubid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.tgtsubid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tgtsubid_.IsDefault()) {
    _impl_.tgtsubid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommHeader::set_allocated_tgtsubid(std::string* tgtsubid) {
  if (tgtsubid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tgtsubid_.SetAllocated(tgtsubid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tgtsubid_.IsDefault()) {
    _impl_.tgtsubid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.intrnl.CommHeader.tgtSubId)
}

// optional int32 msgSrcEnd = 6;
inline bool CommHeader::_internal_has_msgsrcend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CommHeader::has_msgsrcend() const {
  return _internal_has_msgsrcend();
}
inline void CommHeader::clear_msgsrcend() {
  _impl_.msgsrcend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t CommHeader::_internal_msgsrcend() const {
  return _impl_.msgsrcend_;
}
inline int32_t CommHeader::msgsrcend() const {
  // @@protoc_insertion_point(field_get:message.intrnl.CommHeader.msgSrcEnd)
  return _internal_msgsrcend();
}
inline void CommHeader::_internal_set_msgsrcend(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.msgsrcend_ = value;
}
inline void CommHeader::set_msgsrcend(int32_t value) {
  _internal_set_msgsrcend(value);
  // @@protoc_insertion_point(field_set:message.intrnl.CommHeader.msgSrcEnd)
}

// optional string msgSndngTm = 7;
inline bool CommHeader::_internal_has_msgsndngtm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommHeader::has_msgsndngtm() const {
  return _internal_has_msgsndngtm();
}
inline void CommHeader::clear_msgsndngtm() {
  _impl_.msgsndngtm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CommHeader::msgsndngtm() const {
  // @@protoc_insertion_point(field_get:message.intrnl.CommHeader.msgSndngTm)
  return _internal_msgsndngtm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommHeader::set_msgsndngtm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.msgsndngtm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.intrnl.CommHeader.msgSndngTm)
}
inline std::string* CommHeader::mutable_msgsndngtm() {
  std::string* _s = _internal_mutable_msgsndngtm();
  // @@protoc_insertion_point(field_mutable:message.intrnl.CommHeader.msgSndngTm)
  return _s;
}
inline const std::string& CommHeader::_internal_msgsndngtm() const {
  return _impl_.msgsndngtm_.Get();
}
inline void CommHeader::_internal_set_msgsndngtm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.msgsndngtm_.Set(value, GetArenaForAllocation());
}
inline std::string* CommHeader::_internal_mutable_msgsndngtm() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.msgsndngtm_.Mutable(GetArenaForAllocation());
}
inline std::string* CommHeader::release_msgsndngtm() {
  // @@protoc_insertion_point(field_release:message.intrnl.CommHeader.msgSndngTm)
  if (!_internal_has_msgsndngtm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.msgsndngtm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msgsndngtm_.IsDefault()) {
    _impl_.msgsndngtm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommHeader::set_allocated_msgsndngtm(std::string* msgsndngtm) {
  if (msgsndngtm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.msgsndngtm_.SetAllocated(msgsndngtm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msgsndngtm_.IsDefault()) {
    _impl_.msgsndngtm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.intrnl.CommHeader.msgSndngTm)
}

// optional string msgUuid = 8;
inline bool CommHeader::_internal_has_msguuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommHeader::has_msguuid() const {
  return _internal_has_msguuid();
}
inline void CommHeader::clear_msguuid() {
  _impl_.msguuid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CommHeader::msguuid() const {
  // @@protoc_insertion_point(field_get:message.intrnl.CommHeader.msgUuid)
  return _internal_msguuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommHeader::set_msguuid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.msguuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.intrnl.CommHeader.msgUuid)
}
inline std::string* CommHeader::mutable_msguuid() {
  std::string* _s = _internal_mutable_msguuid();
  // @@protoc_insertion_point(field_mutable:message.intrnl.CommHeader.msgUuid)
  return _s;
}
inline const std::string& CommHeader::_internal_msguuid() const {
  return _impl_.msguuid_.Get();
}
inline void CommHeader::_internal_set_msguuid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.msguuid_.Set(value, GetArenaForAllocation());
}
inline std::string* CommHeader::_internal_mutable_msguuid() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.msguuid_.Mutable(GetArenaForAllocation());
}
inline std::string* CommHeader::release_msguuid() {
  // @@protoc_insertion_point(field_release:message.intrnl.CommHeader.msgUuid)
  if (!_internal_has_msguuid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.msguuid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msguuid_.IsDefault()) {
    _impl_.msguuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommHeader::set_allocated_msguuid(std::string* msguuid) {
  if (msguuid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.msguuid_.SetAllocated(msguuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msguuid_.IsDefault()) {
    _impl_.msguuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.intrnl.CommHeader.msgUuid)
}

// optional int32 dplcF = 9;
inline bool CommHeader::_internal_has_dplcf() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CommHeader::has_dplcf() const {
  return _internal_has_dplcf();
}
inline void CommHeader::clear_dplcf() {
  _impl_.dplcf_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int32_t CommHeader::_internal_dplcf() const {
  return _impl_.dplcf_;
}
inline int32_t CommHeader::dplcf() const {
  // @@protoc_insertion_point(field_get:message.intrnl.CommHeader.dplcF)
  return _internal_dplcf();
}
inline void CommHeader::_internal_set_dplcf(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.dplcf_ = value;
}
inline void CommHeader::set_dplcf(int32_t value) {
  _internal_set_dplcf(value);
  // @@protoc_insertion_point(field_set:message.intrnl.CommHeader.dplcF)
}

// optional string sesnId = 10;
inline bool CommHeader::_internal_has_sesnid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommHeader::has_sesnid() const {
  return _internal_has_sesnid();
}
inline void CommHeader::clear_sesnid() {
  _impl_.sesnid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CommHeader::sesnid() const {
  // @@protoc_insertion_point(field_get:message.intrnl.CommHeader.sesnId)
  return _internal_sesnid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommHeader::set_sesnid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.sesnid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.intrnl.CommHeader.sesnId)
}
inline std::string* CommHeader::mutable_sesnid() {
  std::string* _s = _internal_mutable_sesnid();
  // @@protoc_insertion_point(field_mutable:message.intrnl.CommHeader.sesnId)
  return _s;
}
inline const std::string& CommHeader::_internal_sesnid() const {
  return _impl_.sesnid_.Get();
}
inline void CommHeader::_internal_set_sesnid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.sesnid_.Set(value, GetArenaForAllocation());
}
inline std::string* CommHeader::_internal_mutable_sesnid() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.sesnid_.Mutable(GetArenaForAllocation());
}
inline std::string* CommHeader::release_sesnid() {
  // @@protoc_insertion_point(field_release:message.intrnl.CommHeader.sesnId)
  if (!_internal_has_sesnid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.sesnid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sesnid_.IsDefault()) {
    _impl_.sesnid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommHeader::set_allocated_sesnid(std::string* sesnid) {
  if (sesnid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.sesnid_.SetAllocated(sesnid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sesnid_.IsDefault()) {
    _impl_.sesnid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.intrnl.CommHeader.sesnId)
}

// optional string tpcNm = 11;
inline bool CommHeader::_internal_has_tpcnm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CommHeader::has_tpcnm() const {
  return _internal_has_tpcnm();
}
inline void CommHeader::clear_tpcnm() {
  _impl_.tpcnm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CommHeader::tpcnm() const {
  // @@protoc_insertion_point(field_get:message.intrnl.CommHeader.tpcNm)
  return _internal_tpcnm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommHeader::set_tpcnm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.tpcnm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.intrnl.CommHeader.tpcNm)
}
inline std::string* CommHeader::mutable_tpcnm() {
  std::string* _s = _internal_mutable_tpcnm();
  // @@protoc_insertion_point(field_mutable:message.intrnl.CommHeader.tpcNm)
  return _s;
}
inline const std::string& CommHeader::_internal_tpcnm() const {
  return _impl_.tpcnm_.Get();
}
inline void CommHeader::_internal_set_tpcnm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.tpcnm_.Set(value, GetArenaForAllocation());
}
inline std::string* CommHeader::_internal_mutable_tpcnm() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.tpcnm_.Mutable(GetArenaForAllocation());
}
inline std::string* CommHeader::release_tpcnm() {
  // @@protoc_insertion_point(field_release:message.intrnl.CommHeader.tpcNm)
  if (!_internal_has_tpcnm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.tpcnm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tpcnm_.IsDefault()) {
    _impl_.tpcnm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommHeader::set_allocated_tpcnm(std::string* tpcnm) {
  if (tpcnm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.tpcnm_.SetAllocated(tpcnm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tpcnm_.IsDefault()) {
    _impl_.tpcnm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.intrnl.CommHeader.tpcNm)
}

// optional int32 tstMdF = 12;
inline bool CommHeader::_internal_has_tstmdf() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CommHeader::has_tstmdf() const {
  return _internal_has_tstmdf();
}
inline void CommHeader::clear_tstmdf() {
  _impl_.tstmdf_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int32_t CommHeader::_internal_tstmdf() const {
  return _impl_.tstmdf_;
}
inline int32_t CommHeader::tstmdf() const {
  // @@protoc_insertion_point(field_get:message.intrnl.CommHeader.tstMdF)
  return _internal_tstmdf();
}
inline void CommHeader::_internal_set_tstmdf(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.tstmdf_ = value;
}
inline void CommHeader::set_tstmdf(int32_t value) {
  _internal_set_tstmdf(value);
  // @@protoc_insertion_point(field_set:message.intrnl.CommHeader.tstMdF)
}

// -------------------------------------------------------------------

// IntrnlMsgData

// optional int32 msgType = 1;
inline bool IntrnlMsgData::_internal_has_msgtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IntrnlMsgData::has_msgtype() const {
  return _internal_has_msgtype();
}
inline void IntrnlMsgData::clear_msgtype() {
  _impl_.msgtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t IntrnlMsgData::_internal_msgtype() const {
  return _impl_.msgtype_;
}
inline int32_t IntrnlMsgData::msgtype() const {
  // @@protoc_insertion_point(field_get:message.intrnl.IntrnlMsgData.msgType)
  return _internal_msgtype();
}
inline void IntrnlMsgData::_internal_set_msgtype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.msgtype_ = value;
}
inline void IntrnlMsgData::set_msgtype(int32_t value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:message.intrnl.IntrnlMsgData.msgType)
}

// optional int32 msgLen = 2;
inline bool IntrnlMsgData::_internal_has_msglen() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IntrnlMsgData::has_msglen() const {
  return _internal_has_msglen();
}
inline void IntrnlMsgData::clear_msglen() {
  _impl_.msglen_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t IntrnlMsgData::_internal_msglen() const {
  return _impl_.msglen_;
}
inline int32_t IntrnlMsgData::msglen() const {
  // @@protoc_insertion_point(field_get:message.intrnl.IntrnlMsgData.msgLen)
  return _internal_msglen();
}
inline void IntrnlMsgData::_internal_set_msglen(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.msglen_ = value;
}
inline void IntrnlMsgData::set_msglen(int32_t value) {
  _internal_set_msglen(value);
  // @@protoc_insertion_point(field_set:message.intrnl.IntrnlMsgData.msgLen)
}

// optional bytes data = 3;
inline bool IntrnlMsgData::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IntrnlMsgData::has_data() const {
  return _internal_has_data();
}
inline void IntrnlMsgData::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IntrnlMsgData::data() const {
  // @@protoc_insertion_point(field_get:message.intrnl.IntrnlMsgData.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IntrnlMsgData::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.intrnl.IntrnlMsgData.data)
}
inline std::string* IntrnlMsgData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:message.intrnl.IntrnlMsgData.data)
  return _s;
}
inline const std::string& IntrnlMsgData::_internal_data() const {
  return _impl_.data_.Get();
}
inline void IntrnlMsgData::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* IntrnlMsgData::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* IntrnlMsgData::release_data() {
  // @@protoc_insertion_point(field_release:message.intrnl.IntrnlMsgData.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IntrnlMsgData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.intrnl.IntrnlMsgData.data)
}

// -------------------------------------------------------------------

// IntrnlMsgExtData

// optional int32 dataCnt = 1;
inline bool IntrnlMsgExtData::_internal_has_datacnt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IntrnlMsgExtData::has_datacnt() const {
  return _internal_has_datacnt();
}
inline void IntrnlMsgExtData::clear_datacnt() {
  _impl_.datacnt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t IntrnlMsgExtData::_internal_datacnt() const {
  return _impl_.datacnt_;
}
inline int32_t IntrnlMsgExtData::datacnt() const {
  // @@protoc_insertion_point(field_get:message.intrnl.IntrnlMsgExtData.dataCnt)
  return _internal_datacnt();
}
inline void IntrnlMsgExtData::_internal_set_datacnt(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.datacnt_ = value;
}
inline void IntrnlMsgExtData::set_datacnt(int32_t value) {
  _internal_set_datacnt(value);
  // @@protoc_insertion_point(field_set:message.intrnl.IntrnlMsgExtData.dataCnt)
}

// -------------------------------------------------------------------

// IntrnlMsg

// optional .message.intrnl.CommHeader header = 1;
inline bool IntrnlMsg::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline bool IntrnlMsg::has_header() const {
  return _internal_has_header();
}
inline void IntrnlMsg::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::intrnl::CommHeader& IntrnlMsg::_internal_header() const {
  const ::message::intrnl::CommHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::intrnl::CommHeader&>(
      ::message::intrnl::_CommHeader_default_instance_);
}
inline const ::message::intrnl::CommHeader& IntrnlMsg::header() const {
  // @@protoc_insertion_point(field_get:message.intrnl.IntrnlMsg.header)
  return _internal_header();
}
inline void IntrnlMsg::unsafe_arena_set_allocated_header(
    ::message::intrnl::CommHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.intrnl.IntrnlMsg.header)
}
inline ::message::intrnl::CommHeader* IntrnlMsg::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::intrnl::CommHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::message::intrnl::CommHeader* IntrnlMsg::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:message.intrnl.IntrnlMsg.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::intrnl::CommHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::message::intrnl::CommHeader* IntrnlMsg::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::message::intrnl::CommHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::message::intrnl::CommHeader* IntrnlMsg::mutable_header() {
  ::message::intrnl::CommHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:message.intrnl.IntrnlMsg.header)
  return _msg;
}
inline void IntrnlMsg::set_allocated_header(::message::intrnl::CommHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:message.intrnl.IntrnlMsg.header)
}

// repeated .message.intrnl.IntrnlMsgData intrnMsgData = 2;
inline int IntrnlMsg::_internal_intrnmsgdata_size() const {
  return _impl_.intrnmsgdata_.size();
}
inline int IntrnlMsg::intrnmsgdata_size() const {
  return _internal_intrnmsgdata_size();
}
inline void IntrnlMsg::clear_intrnmsgdata() {
  _impl_.intrnmsgdata_.Clear();
}
inline ::message::intrnl::IntrnlMsgData* IntrnlMsg::mutable_intrnmsgdata(int index) {
  // @@protoc_insertion_point(field_mutable:message.intrnl.IntrnlMsg.intrnMsgData)
  return _impl_.intrnmsgdata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::intrnl::IntrnlMsgData >*
IntrnlMsg::mutable_intrnmsgdata() {
  // @@protoc_insertion_point(field_mutable_list:message.intrnl.IntrnlMsg.intrnMsgData)
  return &_impl_.intrnmsgdata_;
}
inline const ::message::intrnl::IntrnlMsgData& IntrnlMsg::_internal_intrnmsgdata(int index) const {
  return _impl_.intrnmsgdata_.Get(index);
}
inline const ::message::intrnl::IntrnlMsgData& IntrnlMsg::intrnmsgdata(int index) const {
  // @@protoc_insertion_point(field_get:message.intrnl.IntrnlMsg.intrnMsgData)
  return _internal_intrnmsgdata(index);
}
inline ::message::intrnl::IntrnlMsgData* IntrnlMsg::_internal_add_intrnmsgdata() {
  return _impl_.intrnmsgdata_.Add();
}
inline ::message::intrnl::IntrnlMsgData* IntrnlMsg::add_intrnmsgdata() {
  ::message::intrnl::IntrnlMsgData* _add = _internal_add_intrnmsgdata();
  // @@protoc_insertion_point(field_add:message.intrnl.IntrnlMsg.intrnMsgData)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message::intrnl::IntrnlMsgData >&
IntrnlMsg::intrnmsgdata() const {
  // @@protoc_insertion_point(field_list:message.intrnl.IntrnlMsg.intrnMsgData)
  return _impl_.intrnmsgdata_;
}

// optional .message.intrnl.IntrnlMsgExtData IntrnlMsgExtData = 3;
inline bool IntrnlMsg::_internal_has_intrnlmsgextdata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.intrnlmsgextdata_ != nullptr);
  return value;
}
inline bool IntrnlMsg::has_intrnlmsgextdata() const {
  return _internal_has_intrnlmsgextdata();
}
inline void IntrnlMsg::clear_intrnlmsgextdata() {
  if (_impl_.intrnlmsgextdata_ != nullptr) _impl_.intrnlmsgextdata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::message::intrnl::IntrnlMsgExtData& IntrnlMsg::_internal_intrnlmsgextdata() const {
  const ::message::intrnl::IntrnlMsgExtData* p = _impl_.intrnlmsgextdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::intrnl::IntrnlMsgExtData&>(
      ::message::intrnl::_IntrnlMsgExtData_default_instance_);
}
inline const ::message::intrnl::IntrnlMsgExtData& IntrnlMsg::intrnlmsgextdata() const {
  // @@protoc_insertion_point(field_get:message.intrnl.IntrnlMsg.IntrnlMsgExtData)
  return _internal_intrnlmsgextdata();
}
inline void IntrnlMsg::unsafe_arena_set_allocated_intrnlmsgextdata(
    ::message::intrnl::IntrnlMsgExtData* intrnlmsgextdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.intrnlmsgextdata_);
  }
  _impl_.intrnlmsgextdata_ = intrnlmsgextdata;
  if (intrnlmsgextdata) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.intrnl.IntrnlMsg.IntrnlMsgExtData)
}
inline ::message::intrnl::IntrnlMsgExtData* IntrnlMsg::release_intrnlmsgextdata() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::intrnl::IntrnlMsgExtData* temp = _impl_.intrnlmsgextdata_;
  _impl_.intrnlmsgextdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::message::intrnl::IntrnlMsgExtData* IntrnlMsg::unsafe_arena_release_intrnlmsgextdata() {
  // @@protoc_insertion_point(field_release:message.intrnl.IntrnlMsg.IntrnlMsgExtData)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::intrnl::IntrnlMsgExtData* temp = _impl_.intrnlmsgextdata_;
  _impl_.intrnlmsgextdata_ = nullptr;
  return temp;
}
inline ::message::intrnl::IntrnlMsgExtData* IntrnlMsg::_internal_mutable_intrnlmsgextdata() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.intrnlmsgextdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::message::intrnl::IntrnlMsgExtData>(GetArenaForAllocation());
    _impl_.intrnlmsgextdata_ = p;
  }
  return _impl_.intrnlmsgextdata_;
}
inline ::message::intrnl::IntrnlMsgExtData* IntrnlMsg::mutable_intrnlmsgextdata() {
  ::message::intrnl::IntrnlMsgExtData* _msg = _internal_mutable_intrnlmsgextdata();
  // @@protoc_insertion_point(field_mutable:message.intrnl.IntrnlMsg.IntrnlMsgExtData)
  return _msg;
}
inline void IntrnlMsg::set_allocated_intrnlmsgextdata(::message::intrnl::IntrnlMsgExtData* intrnlmsgextdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.intrnlmsgextdata_;
  }
  if (intrnlmsgextdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intrnlmsgextdata);
    if (message_arena != submessage_arena) {
      intrnlmsgextdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intrnlmsgextdata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.intrnlmsgextdata_ = intrnlmsgextdata;
  // @@protoc_insertion_point(field_set_allocated:message.intrnl.IntrnlMsg.IntrnlMsgExtData)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace intrnl
}  // namespace message

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_IntrnlMsg_2eproto
